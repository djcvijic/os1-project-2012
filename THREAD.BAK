#include "thread.h"
#include "pcb.h"
#include "prekidi.h"


void globRun(){
	PCB::running->run();
}

char *strcpy(char *dst, const char *src)
{
 char *ptr;
 ptr = dst;
 while (*src) *dst++ = *src++;
 *dst = 0;
 return(ptr);
}

void dispatch(){ // sinhrona promena konteksta
	lock
	Prekidi::zahtevana_promena_konteksta = 1;
	timer();
	unlock
}

void Thread::start(){
	lock
	myPCB->start();
	unlock
}

int Thread::waitToComplete(){
	return myPCB->waitToComplete();
}

int Thread::wakeUp(){
	return myPCB->wakeUp();
}

int Thread::sleep(Time timeToSleep){
	return PCB::running->sleep(timeToSleep);
}

ID Thread::getId(){
	return myPCB->tId;
}

TName Thread::getName(){
	return myPCB->tName;
}

Thread * Thread::getThreadById(ID id){
	for (ThreadElem * tek = PCB::threadList; tek != NULL; tek = tek->sled) {
		if (tek->pcb->tId == id) return tek->thread;
	}
	return NULL;
}

ID Thread::getIdOf(TName name){
	for (ThreadElem * tek = PCB::threadList; tek != NULL; tek = tek->sled) {
		if (tek->pcb->tName == name) return tek->pcb->tId;
	}
	return NULL;
}

Thread::~Thread(){
	while (!this->waitToComplete()) {}
}

Thread::Thread (TName name,StackSize stackSize,Time timeSlice){
	lock
	myPCB = new PCB(this,timeSlice);
	char* newName = new char[12];
	if (name) {
		strcpy (newName, name);
	}
	else {
		strcpy (newName, "thread");
		char * toAppend = itoa (myPCB->tId, new char[6], 10);
		strcpy (newName + 6, toAppend);
	}
	myPCB->tName = newName;
	myPCB->createProcess(globRun, stackSize);
	PCB::threadList = new ThreadElem(this, myPCB, PCB::threadList);
	lockCout
	cout<<"napravio "<<myPCB->tName<<" id= "<<myPCB->tId<<endl;
	unlockCout
	unlock
}